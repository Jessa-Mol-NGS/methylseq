nextflow_pipeline {
    name "Test Workflow main.nf - Core Alignment Parameters"
    script "../main.nf"
    config "./nextflow.config"
    tag "cpu"

    // Define core alignment parameter test scenarios
    def testScenarios = [
        [
            name: "bismark_non_directional",
            description: "Params: bismark | non_directional",
            params: [
                non_directional: true
            ]
        ],
        [
            name: "bismark_hisat_non_directional",
            description: "Params: bismark_hisat | non_directional",
            params: [
                aligner: "bismark_hisat",
                non_directional: true
            ]
        ],
        [
            name: "bismark_hisat_known_splices",
            description: "Params: bismark_hisat | known_splices",
            params: [
                aligner: "bismark_hisat",
                known_splices: "\${projectDir}/assets/genome_target_regions.bed"
            ]
        ],
        [
            name: "bismark_local_alignment",
            description: "Params: bismark | local_alignment",
            params: [
                local_alignment: true
            ]
        ],
        [
            name: "bismark_hisat_local_alignment",
            description: "Params: bismark_hisat | local_alignment",
            params: [
                aligner: "bismark_hisat",
                local_alignment: true
            ]
        ],
        [
            name: "bismark_relax_mismatches_default",
            description: "Params: bismark | relax_mismatches (default num_mismatches)",
            params: [
                relax_mismatches: true
            ]
        ],
        [
            name: "bismark_relax_mismatches_custom",
            description: "Params: bismark | relax_mismatches | num_mismatches 0.8",
            params: [
                relax_mismatches: true,
                num_mismatches: 0.8
            ]
        ],
        [
            name: "bismark_hisat_relax_mismatches",
            description: "Params: bismark_hisat | relax_mismatches | num_mismatches 0.4",
            params: [
                aligner: "bismark_hisat",
                relax_mismatches: true,
                num_mismatches: 0.4
            ]
        ],
        [
            name: "bismark_combined_alignment_options",
            description: "Params: bismark | non_directional | local_alignment | relax_mismatches",
            params: [
                non_directional: true,
                local_alignment: true,
                relax_mismatches: true,
                num_mismatches: 0.5
            ]
        ],
        [
            name: "bismark_hisat_combined_alignment_options",
            description: "Params: bismark_hisat | non_directional | local_alignment | known_splices",
            params: [
                aligner: "bismark_hisat",
                non_directional: true,
                local_alignment: true,
                known_splices: "\${projectDir}/assets/genome_target_regions.bed"
            ]
        ]
    ]

    // Functional assertion functions for alignment parameters
    def checkNonDirectionalAlignment = { outputDir ->
        def bismarkReport = getAllFilesFromDir(outputDir, include: ['**/bismark_summary_report.txt'])
        if (bismarkReport.size() > 0) {
            def reportContent = bismarkReport[0].text
            // Check for alignment to multiple strands
            def hasOT = reportContent.contains("OT:") || reportContent.contains("original top")
            def hasOB = reportContent.contains("OB:") || reportContent.contains("original bottom") 
            def hasCTOT = reportContent.contains("CTOT:") || reportContent.contains("complementary")
            def hasCTOB = reportContent.contains("CTOB:") || reportContent.contains("complementary")
            return hasOT && hasOB && (hasCTOT || hasCTOB)
        }
        return true // Pass if no report found (may be different aligner)
    }
    
    def checkLocalAlignment = { outputDir ->
        def bamFiles = getAllFilesFromDir(outputDir, include: ['**/*.bam'])
        if (bamFiles.size() > 0) {
            // Check for soft-clipped reads in BAM (CIGAR strings with 'S')
            def bamFile = bamFiles[0]
            def hasSoftClips = false
            try {
                // Use samtools to check for soft-clipped reads
                def proc = "samtools view ${bamFile.toString()} | head -1000 | grep -E '[0-9]+S' | wc -l".execute()
                proc.waitFor()
                def softClipCount = proc.text.trim() as Integer
                hasSoftClips = softClipCount > 0
            } catch (Exception e) {
                // Fallback: assume test passes if samtools not available
                hasSoftClips = true
            }
            return hasSoftClips
        }
        return true
    }
    
    def checkRelaxedMismatches = { outputDir ->
        def bismarkReport = getAllFilesFromDir(outputDir, include: ['**/bismark_summary_report.txt'])
        if (bismarkReport.size() > 0) {
            def reportContent = bismarkReport[0].text
            // Extract alignment efficiency - should be higher with relaxed mismatches
            def alignmentRate = 0.0
            reportContent.eachLine { line ->
                if (line.contains("Mapping efficiency:") || line.contains("overall alignment rate")) {
                    def matcher = line =~ /(\d+\.?\d*)%/
                    if (matcher) {
                        alignmentRate = matcher[0][1] as Double
                    }
                }
            }
            // Expect at least some alignment when mismatches are relaxed
            return alignmentRate > 0.0
        }
        return true
    }
    
    def checkKnownSplices = { outputDir ->
        def hisat2Report = getAllFilesFromDir(outputDir, include: ['**/hisat2_summary.txt', '**/bismark_summary_report.txt'])
        if (hisat2Report.size() > 0) {
            def reportContent = hisat2Report[0].text
            // Check for splice junction information
            def hasSpliceInfo = reportContent.contains("splice") || 
                               reportContent.contains("junction") ||
                               reportContent.contains("concordant") ||
                               reportContent.contains("spliced")
            return hasSpliceInfo
        }
        return true // Pass if no specific report found
    }
    
    def runFunctionalAssertions = { outputDir, testParams ->
        def results = [:]
        results.workflowSuccess = workflow.success
        results.taskCount = workflow.trace.succeeded().size()
        
        // Test-specific functional assertions based on parameters
        if (testParams.containsKey('non_directional') && testParams.non_directional) {
            results.nonDirectionalCheck = checkNonDirectionalAlignment(outputDir)
        }
        
        if (testParams.containsKey('local_alignment') && testParams.local_alignment) {
            results.localAlignmentCheck = checkLocalAlignment(outputDir)
        }
        
        if (testParams.containsKey('relax_mismatches') && testParams.relax_mismatches) {
            results.relaxedMismatchesCheck = checkRelaxedMismatches(outputDir)
        }
        
        if (testParams.containsKey('known_splices')) {
            results.knownSplicesCheck = checkKnownSplices(outputDir)
        }
        
        return results
    }

    // Generate tests for each scenario
    testScenarios.each { scenario ->
        test(scenario.description) {
            when {
                params {
                    outdir = "$outputDir"
                    // Apply scenario-specific parameters
                    scenario.params.each { key, value ->
                        if (key == 'known_splices' && value.contains('projectDir')) {
                            // Handle special case for projectDir expansion in known_splices
                            known_splices = "${projectDir}/assets/genome_target_regions.bed"
                        } else {
                            delegate."$key" = value
                        }
                    }
                }
            }

            then {
                def functionalResults = runFunctionalAssertions(params.outdir, scenario.params)
                
                assertAll(
                    { assert workflow.success },
                    { assert functionalResults.workflowSuccess },
                    { assert functionalResults.taskCount > 0 },
                    // Parameter-specific functional assertions
                    scenario.params.containsKey('non_directional') && scenario.params.non_directional ? 
                        { assert functionalResults.nonDirectionalCheck } : { assert true },
                    scenario.params.containsKey('local_alignment') && scenario.params.local_alignment ? 
                        { assert functionalResults.localAlignmentCheck } : { assert true },
                    scenario.params.containsKey('relax_mismatches') && scenario.params.relax_mismatches ? 
                        { assert functionalResults.relaxedMismatchesCheck } : { assert true },
                    scenario.params.containsKey('known_splices') ? 
                        { assert functionalResults.knownSplicesCheck } : { assert true },
                    { assert snapshot(functionalResults).match() }
                )
            }
        }
    }
} 